# -*- coding: utf-8 -*-
"""reducao_dimensionalidade_binarização.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/18o2qXNf1PhRxzrhhdNiaVG0ULtIBK3Qb

Passo 1: Importação das bibliotecas
"""

import cv2 as cv
import numpy as np
from matplotlib import pyplot as plt
import sys

"""Passo 2: Ler a imagem"""

# Ler imagem usando a biblioteca opencv
img = cv.imread("images/image.png")

# Verifica se foi possivel ler a imagem caso contrário retorna a mensagem e encerra aplicação
if img is None:
    sys.exit("Não foi possível ler a imagem.")

"""Passo 3: Tratar as imagens"""

# Criei uma função para reduzir o tamanho da imagem
def resize_image(new_width: int) -> None:
  factor = new_width / img.shape[1]
  new_height = int(img.shape[0] * factor)
  return new_width, new_height

# Uso da função para reduzir a imagem proporcionalmente para a largura 350px
img = cv.resize(img, resize_image(350))

# Para não haver alteração ao plotar a imagem pelo matplotlib, precisamos converter a imagem de BGR para RGB
img_rgb = cv.cvtColor(img, cv.COLOR_BGR2RGB)
# Reduz a dimensionalidade para escalas de cinza 0 a 255
img_gray = cv.cvtColor(img_rgb, cv.COLOR_RGB2GRAY)
# Reduz a dimensionalidade binarizando, sendo necessário usar o método OTSU para realizar cálculo automático do melhor threshold baseado no histograma da imagem.
_, img_bin = cv.threshold(img_gray, 0, 255, cv.THRESH_BINARY + cv.THRESH_OTSU)

print("Original: ", img_rgb.shape)
print("Escala de Cinza: ", img_gray.shape)
print("Binarizada: ", img_bin.shape)

print("Threshold calculado: ", _)

"""Passo 4: Exibir as Imagens"""

# Para otimizar a exibição, criei um dicionário com indice e valor
images = {"RBG": img_rgb, "Escala de Cinza": img_gray, "Binarizada": img_bin}

# Ajustar o tamanho para exibição
plt.figure(figsize=(12,8))

# Iteração do dicionário para colocar titulo adequado em cada imagem
for i, (title, image) in enumerate(images.items()):
    plt.subplot(1, 3, i + 1) # Determina a plotagem em uma linha e 3 colunas
    plt.title(title) # Determina a plotagem do titulo
    # Verifica se o title na iteração é um RGB
    if title == "RGB":
      plt.imshow(image)
    else: # se não for RBG ele precisa determinar o cmap="gray", para garantir que apareçam em tons de cinza reais, não em cores estranhas.
      plt.imshow(image, cmap="gray")
    plt.axis("off") # para não plotar os eixos

plt.show()